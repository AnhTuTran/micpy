/* -*- c -*- */
#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"


#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#define _NPY_NO_DEPRECATIONS /* for NPY_CHAR */

#define PY_ARRAY_UNIQUE_SYMBOL MICPY_ARRAY_API
#define NO_IMPORT_ARRAY
#include "numpy/npy_common.h"
#include "numpy/arrayobject.h"
#include "numpy/arrayscalars.h"
#include "numpy/npy_3kcompat.h"
#include "numpy/npy_math.h"

#define _MICARRAYMODULE
#include <mpymath/halffloat.h>
#include "arrayobject.h"
//#include "npy_config.h"
//#include "npy_sort.h"
#include "common.h"
//#include "creators.h"
#include "lowlevel_strided_loops.h"
//#include "usertypes.h"
//#include "_datetime.h"
#include "arrayobject.h"
#include "alloc.h"

//#include "numpyos.h"
#include <string.h>

//#include "cblasfuncs.h"
#include <mkl.h>
//#include "npy_cblas.h"
#include <limits.h>
#include <assert.h>


/*
 *****************************************************************************
 **                        PYTHON TYPES TO C TYPES                          **
 *****************************************************************************
 */


/*
 *****************************************************************************
 **                         GETITEM AND SETITEM                             **
 *****************************************************************************
 */


/*
 *****************************************************************************
 **                       TYPE TO TYPE CONVERSIONS                          **
 *****************************************************************************
 */


/*
 *****************************************************************************
 **                               SCAN                                      **
 *****************************************************************************
 */


/*
 *****************************************************************************
 **                             FROMSTR                                     **
 *****************************************************************************
 */


/*
 *****************************************************************************
 **                            COPYSWAPN                                    **
 *****************************************************************************
 */


/*
 *****************************************************************************
 **                                 NONZERO                                 **
 *****************************************************************************
 */


/*
 *****************************************************************************
 **                                 COMPARE                                 **
 *****************************************************************************
 */


/* boolean type */

static int
BOOL_compare(npy_bool *ip1, npy_bool *ip2, PyMicArrayObject *ap)
{
    int device = PyMicArray_DEVICE(ap);
    int result;

    #pragma omp target device(device) map(to: ip1, ip2) map(from: result)
    result = (*ip1 ? (*ip2 ? 0 : 1) : (*ip2 ? -1 : 0));

    return result;
}


/* integer types */

/**begin repeat
 * #TYPE = BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         DATETIME, TIMEDELTA#
 * #type = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_datetime, npy_timedelta#
 */

static int
@TYPE@_compare (@type@ *pa, @type@ *pb, PyMicArrayObject *ap)
{
    int device = PyMicArray_DEVICE(ap);
    int result;

    #pragma omp target device(device) map(to: pa,pb) map(from: result)
    {
        const @type@ a = *pa;
        const @type@ b = *pb;

        result = a < b ? -1 : a == b ? 0 : 1;
    }

    return result;
}

/**end repeat**/


/* float types */

/*
 * The real/complex comparison functions are compatible with the new sort
 * order for nans introduced in numpy 1.4.0. All nan values now compare
 * larger than non-nan values and are sorted to the end. The comparison
 * order is:
 *
 *      Real: [R, nan]
 *      Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
 *
 *  where complex values with the same nan placements are sorted according
 *  to the non-nan part if it exists. If both the real and imaginary parts
 *  of complex types are non-nan the order is the same as the real parts
 *  unless they happen to be equal, in which case the order is that of the
 *  imaginary parts.
 */

/**begin repeat
 *
 * #TYPE = FLOAT, DOUBLE, LONGDOUBLE#
 * #type = npy_float, npy_double, npy_longdouble#
 */

#define LT(a,b) ((a) < (b) || ((b) != (b) && (a) ==(a)))

static int
@TYPE@_compare(@type@ *pa, @type@ *pb)
{
    const @type@ a = *pa;
    const @type@ b = *pb;
    int ret;

    if (LT(a,b)) {
        ret = -1;
    }
    else if (LT(b,a)) {
        ret = 1;
    }
    else {
        ret = 0;
    }
    return ret;
}


static int
C@TYPE@_compare(@type@ *pa, @type@ *pb)
{
    const @type@ ar = pa[0];
    const @type@ ai = pa[1];
    const @type@ br = pb[0];
    const @type@ bi = pb[1];
    int ret;

    if (ar < br) {
        if (ai == ai || bi != bi) {
            ret = -1;
        }
        else {
            ret = 1;
        }
    }
    else if (br < ar) {
        if (bi == bi || ai != ai) {
            ret = 1;
        }
        else {
            ret = -1;
        }
    }
    else if (ar == br || (ar != ar && br != br)) {
        if (LT(ai,bi)) {
            ret = -1;
        }
        else if (LT(bi,ai)) {
            ret = 1;
        }
        else {
            ret = 0;
        }
    }
    else if (ar == ar) {
        ret = -1;
    }
    else {
        ret = 1;
    }

    return ret;
}

#undef LT

/**end repeat**/

static int
HALF_compare (npy_half *pa, npy_half *pb, PyArrayObject *NPY_UNUSED(ap))
{
    npy_half a = *pa, b = *pb;
    npy_bool a_isnan, b_isnan;
    int ret;

    a_isnan = mpy_half_isnan(a);
    b_isnan = mpy_half_isnan(b);

    if (a_isnan) {
        ret = b_isnan ? 0 : -1;
    }
    else if (b_isnan) {
        ret = 1;
    }
    else if(mpy_half_lt_nonan(a, b)) {
        ret = -1;
    }
    else if(mpy_half_lt_nonan(b, a)) {
        ret = 1;
    }
    else {
        ret = 0;
    }

    return ret;
}


/* object type */


/* string type */



/* unicode type */


/* void type */

/*
 * If fields are defined, then compare on first field and if equal
 * compare on second field.  Continue until done or comparison results
 * in not_equal.
 *
 * Must align data passed on to sub-comparisons.
 * Also must swap data based on to sub-comparisons.
 */


/*
 *****************************************************************************
 **                                 ARGFUNC                                 **
 *****************************************************************************
 */

/************************** MAYBE USE CBLAS *********************************/


/**begin repeat
 *
 * #name = FLOAT, DOUBLE#
 * #type = npy_float, npy_double#
 * #prefix = s, d#
 */
NPY_NO_EXPORT int
@name@_argmax(@type@ *ip, npy_intp n, npy_intp *max_ind, int device)
{
    npy_intp mymax_ind, cmax_ind;

    #pragma omp target device(device) map(to: ip, n) map(from: mymax_ind)
    {
        @type@ *arr = ip;
        int chunk = n < MPY_CBLAS_CHUNK ? n : MPY_CBLAS_CHUNK;

        mymax_ind = cblas_i@prefix@amax(chunk, ip, 1);

        ip += chunk;
        n -= chunk;
        npy_intp pre_chunk = 0;

        while (n > 0) {
            pre_chunk += chunk;
            chunk = n < MPY_CBLAS_CHUNK ? n : MPY_CBLAS_CHUNK;

            cmax_ind = pre_chunk + cblas_i@prefix@amax(chunk, ip, 1);

            if (arr[cmax_ind] > arr[mymax_ind]) {
                mymax_ind = cmax_ind;
            }
            /* use char strides here */
            ip += chunk;
            n -= chunk;
        }
    }
    *max_ind = mymax_ind;
    return 0;
}
/**end repeat**/


#define _LESS_THAN_OR_EQUAL(a,b) ((a) <= (b))

static int
BOOL_argmax(npy_bool *ip, npy_intp n, npy_intp *max_ind,
            int device)

{
    npy_intp i = 0;
    int result;
    /* memcmp like logical_and on i386 is maybe slower for small arrays */
    //TODO: implement IMCI instrinsic
/*#ifdef NPY_HAVE_SSE2_INTRINSICS
    const __m128i zero = _mm_setzero_si128();
    for (; i < n - (n % 32); i+=32) {
        __m128i d1 = _mm_loadu_si128((__m128i*)&ip[i]);
        __m128i d2 = _mm_loadu_si128((__m128i*)&ip[i + 16]);
        d1 = _mm_cmpeq_epi8(d1, zero);
        d2 = _mm_cmpeq_epi8(d2, zero);
        if (_mm_movemask_epi8(_mm_min_epu8(d1, d2)) != 0xFFFF) {
            break;
        }
    }
#endif*/

    #pragma omp target device(device) map(to: ip, n) map(from: result)
    {
        int found = 0;
        for (; i < n; i++) {
            if (ip[i]) {
                result = i;
                found = 1;
                break;
            }
        }
        if (!found)
            result = 0;
    }

    *max_ind = result;
    return 0;
}

/**begin repeat
 *
 * #fname = BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *          LONG, ULONG, LONGLONG, ULONGLONG,
 *          HALF, LONGDOUBLE,
 *          CFLOAT, CDOUBLE, CLONGDOUBLE,
 *          DATETIME, TIMEDELTA#
 * #type = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_longdouble,
 *         npy_float, npy_double, npy_longdouble,
 *         npy_datetime, npy_timedelta#
 * #isfloat = 0*10, 1*5, 0*2#
 * #isnan = nop*10, mpy_half_isnan, isnan*4, nop*2#
 * #le = _LESS_THAN_OR_EQUAL*10, mpy_half_le, _LESS_THAN_OR_EQUAL*6#
 * #iscomplex = 0*12, 1*3, 0*2#
 * #incr = ip++*12, ip+=2*3, ip++*2#
 */
static int
@fname@_argmax(@type@ *ip, npy_intp n, npy_intp *max_ind,
        PyArrayObject *NPY_UNUSED(aip))
{
    npy_intp i;
    @type@ mp = *ip;
#if @iscomplex@
    @type@ mp_im = ip[1];
#endif

    *max_ind = 0;

#if @isfloat@
    if (@isnan@(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if @iscomplex@
    if (@isnan@(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        @incr@;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if @iscomplex@
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || @isnan@(ip[0]) || @isnan@(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (@isnan@(mp) || @isnan@(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!@le@(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if @isfloat@
            if (@isnan@(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}

/**end repeat**/

static int
BOOL_argmin(npy_bool *ip, npy_intp n, npy_intp *min_ind,
            PyArrayObject *NPY_UNUSED(aip))

{
    npy_bool * p = memchr(ip, 0, n * sizeof(*ip));
    if (p == NULL) {
        *min_ind = 0;
        return 0;
    }
    *min_ind = p - ip;
    return 0;
}

/**begin repeat
 *
 * #fname = BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *          LONG, ULONG, LONGLONG, ULONGLONG,
 *          HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *          CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_float, npy_double, npy_longdouble#
 * #isfloat = 0*10, 1*7#
 * #isnan = nop*10, mpy_half_isnan, isnan*6#
 * #le = _LESS_THAN_OR_EQUAL*10, mpy_half_le, _LESS_THAN_OR_EQUAL*6#
 * #iscomplex = 0*14, 1*3#
 * #incr = ip++*14, ip+=2*3#
 */
static int
@fname@_argmin(@type@ *ip, npy_intp n, npy_intp *min_ind,
        PyMicArrayObject *aip)
{
    npy_intp i;
    @type@ mp = *ip;
#if @iscomplex@
    @type@ mp_im = ip[1];
#endif

    *min_ind = 0;

#if @isfloat@
    if (@isnan@(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if @iscomplex@
    if (@isnan@(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        @incr@;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if @iscomplex@
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || @isnan@(ip[0]) || @isnan@(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (@isnan@(mp) || @isnan@(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!@le@(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if @isfloat@
            if (@isnan@(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}

/**end repeat**/

#undef _LESS_THAN_OR_EQUAL

/**begin repeat
 *
 * #fname = DATETIME, TIMEDELTA#
 * #type = npy_datetime, npy_timedelta#
 */
static int
@fname@_argmin(@type@ *ip, npy_intp n, npy_intp *min_ind,
        PyArrayObject *NPY_UNUSED(aip))
{
    /* NPY_DATETIME_NAT is smaller than every other value, we skip
     * it for consistency with min().
     */
    npy_intp i;
    @type@ mp = NPY_DATETIME_NAT;

    i = 0;
    while (i < n && mp == NPY_DATETIME_NAT) {
        mp = ip[i];
        i++;
    }
    if (i == n) {
        /* All NaTs: return 0 */
        *min_ind = 0;
        return 0;
    }
    *min_ind = i - 1;
    for (; i < n; i++) {
        if (mp > ip[i] && ip[i] != NPY_DATETIME_NAT) {
            mp = ip[i];
            *min_ind = i;
        }
    }
    return 0;
}

/**end repeat**/


#define VOID_argmax NULL


#define VOID_argmin NULL


/*
 *****************************************************************************
 **                                  DOT                                    **
 *****************************************************************************
 */

/*
 * dot means inner product
 */

/************************** MAYBE USE CBLAS *********************************/


/**begin repeat
 *
 * #name = FLOAT, DOUBLE#
 * #type = npy_float, npy_double#
 * #prefix = s, d#
 */
NPY_NO_EXPORT void
@name@_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2, char *op,
           npy_intp n, int device)
{
    int is1b = blas_stride(is1, sizeof(@type@));
    int is2b = blas_stride(is2, sizeof(@type@));

    if (is1b && is2b)
    {
        double sum; /* double for stability */
        #pragma omp target device(device) map(to: n, ip1, is1b, ip2, is2b) \
                                          map(from: sum)
        {
            sum = 0.0;  

            while (n > 0) {
                int chunk = n < MPY_CBLAS_CHUNK ? n : MPY_CBLAS_CHUNK;

                sum += cblas_@prefix@dot(chunk,
                                        (@type@ *) ip1, is1b,
                                        (@type@ *) ip2, is2b);
                /* use char strides here */
                ip1 += chunk * is1;
                ip2 += chunk * is2;
                n -= chunk;
            }
        }
        *((@type@ *)op) = (@type@)sum;
    }
    else
    {
        double sum;  /* could make this double */
        npy_intp i;

        #pragma omp target device(device) map(to: n, ip1, is1, ip2, is2)\
                                          map(from: sum)
        {
            sum = 0.0;
            for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
                const @type@ ip1r = *((@type@ *)ip1);
                const @type@ ip2r = *((@type@ *)ip2);

                sum += ip1r * ip2r;
            }
        }
        *((@type@ *)op) = sum;
    }
}
/**end repeat**/

/**begin repeat
 *
 * #name = CFLOAT, CDOUBLE#
 * #ctype = npy_cfloat, npy_cdouble#
 * #type = npy_float, npy_double#
 * #prefix = c, z#
 */
NPY_NO_EXPORT void
@name@_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2,
           char *op, npy_intp n, int device)
{
    int is1b = blas_stride(is1, sizeof(@ctype@));
    int is2b = blas_stride(is2, sizeof(@ctype@));

    if (is1b && is2b) {
        double sum[2]; /* double for stability */

        #pragma omp target device(device) map(to: n, ip1, is1b, ip2, is2b)\
                                          map(from: sum)
        {
            sum[0] = sum[1] = 0.0;

            while (n > 0) {
                int chunk = n < MPY_CBLAS_CHUNK ? n : MPY_CBLAS_CHUNK;
                @type@ tmp[2];

                cblas_@prefix@dotu_sub((int)n, ip1, is1b, ip2, is2b, tmp);
                sum[0] += (double)tmp[0];
                sum[1] += (double)tmp[1];
                /* use char strides here */
                ip1 += chunk * is1;
                ip2 += chunk * is2;
                n -= chunk;
            }
        }
        ((@type@ *)op)[0] = (@type@)sum[0];
        ((@type@ *)op)[1] = (@type@)sum[1];
    }
    else
    {
        double sumr, sumi; /* double for stability */

        npy_intp i;

        #pragma omp target device(device) map(to: n, ip1, is1, ip2, is2)\
                                          map(from: sumr, sumi)
        {
            sumr = sumi = 0.0;
            for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
                const @type@ ip1r = ((@type@ *)ip1)[0];
                const @type@ ip1i = ((@type@ *)ip1)[1];
                const @type@ ip2r = ((@type@ *)ip2)[0];
                const @type@ ip2i = ((@type@ *)ip2)[1];

                sumr += ip1r * ip2r - ip1i * ip2i;
                sumi += ip1r * ip2i + ip1i * ip2r;
            }
        }
        ((@type@ *)op)[0] = sumr;
        ((@type@ *)op)[1] = sumi;
    }
}

/**end repeat**/

/**************************** NO CBLAS VERSIONS *****************************/

static void
BOOL_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2, char *op, npy_intp n,
         int device)
{
    npy_bool tmp;
    npy_intp i;

    #pragma omp target device(device) map(to: n, ip1, is1, ip2, is2)\
                                      map(from: tmp)
    {                               
        tmp = NPY_FALSE;
        for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
            if ((*((npy_bool *)ip1) != 0) && (*((npy_bool *)ip2) != 0)) {
                tmp = NPY_TRUE;
                break;
            }
        }
    }
    *((npy_bool *)op) = tmp;
}

/**begin repeat
 *
 * #name = BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         LONGDOUBLE, DATETIME, TIMEDELTA#
 * #type = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_longdouble, npy_datetime, npy_timedelta#
 * #out = npy_long, npy_ulong, npy_long, npy_ulong, npy_long, npy_ulong,
 *        npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *        npy_longdouble, npy_datetime, npy_timedelta#
 */
static void
@name@_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2, char *op, npy_intp n,
           int device)
{
    @out@ tmp;
    npy_intp i;

    #pragma omp target device(device) map(to: n, ip1, is1, ip2, is2)\
                                      map(from: tmp)
    {
        tmp = (@out@)0;
        for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
            tmp += (@out@)(*((@type@ *)ip1)) *
                (@out@)(*((@type@ *)ip2));
        }
    }
    *((@type@ *)op) = (@type@) tmp;
}
/**end repeat**/

static void
HALF_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2, char *op,
         npy_intp n, int device) 
{
    float tmp = 0.0f;
    npy_intp i;

    #pragma omp target device(device) map(to: n, ip1, is1, ip2, is2)\
                                      map(from: tmp)
    {
        tmp = 0.0f;
        for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
            tmp += mpy_half_to_float(*((npy_half *)ip1)) *
                mpy_half_to_float(*((npy_half *)ip2));
        }
    }
    *((npy_half *)op) = mpy_float_to_half(tmp);
}

static void
CLONGDOUBLE_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2,
                            char *op, npy_intp n, int device)
{
    npy_longdouble tmpr = 0.0L;
    npy_longdouble tmpi = 0.0L;
    npy_intp i;

    #pragma omp target device(device) map(to: n, ip1, is1, ip2, is2)\
                                      map(from: tmpr, tmpi)
    {
        tmpr = tmpi = 0.0L;
        for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
            const npy_longdouble ip1r = ((npy_longdouble *)ip1)[0];
            const npy_longdouble ip1i = ((npy_longdouble *)ip1)[1];
            const npy_longdouble ip2r = ((npy_longdouble *)ip2)[0];
            const npy_longdouble ip2i = ((npy_longdouble *)ip2)[1];

            tmpr += ip1r * ip2r - ip1i * ip2i;
            tmpi += ip1r * ip2i + ip1i * ip2r;
        }
    }
    ((npy_longdouble *)op)[0] = tmpr;
    ((npy_longdouble *)op)[1] = tmpi;
}


/*
 *****************************************************************************
 **                                 FILL                                    **
 *****************************************************************************
 */


#define BOOL_fill NULL

/* this requires buffer to be filled with objects or NULL */


/**begin repeat
 *
 * #NAME = BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         FLOAT, DOUBLE, LONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_float, npy_double, npy_longdouble,
 *         npy_datetime, npy_timedelta#
*/
static void
@NAME@_fill(@type@ *buffer, npy_intp length, int device)
{
    npy_intp i;

    #pragma omp target device(device) map(to: buffer, length)
    {
        @type@ start = buffer[0];
        @type@ delta = buffer[1];

        delta -= start;
        for (i = 2; i < length; ++i) {
            buffer[i] = start + i*delta;
        }
    }
}
/**end repeat**/

static void
HALF_fill(npy_half *buffer, npy_intp length, int device)
{
    npy_intp i;

    #pragma omp target device(device) map(to: buffer, length)
    {
        float start = mpy_half_to_float(buffer[0]);
        float delta = mpy_half_to_float(buffer[1]);

        delta -= start;
        for (i = 2; i < length; ++i) {
            buffer[i] = mpy_float_to_half(start + i*delta);
        }
    }
}

/**begin repeat
 *
 * #NAME = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = npy_cfloat, npy_cdouble, npy_clongdouble#
*/
static void
@NAME@_fill(@type@ *buffer, npy_intp length, int device)
{
    npy_intp i;
    @type@ start;
    @type@ delta;

    #pragma omp target device(device) map(to: buffer, length)
    {
        start.real = buffer->real;
        start.imag = buffer->imag;
        delta.real = buffer[1].real;
        delta.imag = buffer[1].imag;
        delta.real -= start.real;
        delta.imag -= start.imag;
        buffer += 2;
        for (i = 2; i < length; i++, buffer++) {
            buffer->real = start.real + i*delta.real;
            buffer->imag = start.imag + i*delta.imag;
        }
    }
}
/**end repeat**/


/**begin repeat
 *
 * #NAME = BOOL, BYTE, UBYTE#
 * #type = npy_bool, npy_byte, npy_ubyte#
 */
static void
@NAME@_fillwithscalar(@type@ *buffer, npy_intp length, @type@ *value,
        int device)
{
    @type@ val = *value;
    #pragma omp target device(device) map(to: buffer, length, val)
    memset(buffer, val, length);
}
/**end repeat**/

/**begin repeat
 *
 * #NAME = SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_cfloat, npy_cdouble, npy_clongdouble,
 *         npy_datetime, npy_timedelta#
 */
static void
@NAME@_fillwithscalar(@type@ *buffer, npy_intp length, @type@ *value,
        int device)
{
    npy_intp i;
    @type@ val = *value;

    #pragma omp target device(device) map(to: buffer, length, val)
    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}
/**end repeat**/


/*
 *****************************************************************************
 **                               FASTCLIP                                  **
 *****************************************************************************
 */

#define _LESS_THAN(a, b) ((a) < (b))
#define _GREATER_THAN(a, b) ((a) > (b))

/*
 * In fastclip, 'b' was already checked for NaN, so the half comparison
 * only needs to check 'a' for NaN.
 */

#define _HALF_LESS_THAN(a, b) (!mpy_half_isnan(a) && mpy_half_lt_nonan(a, b))
#define _HALF_GREATER_THAN(a, b) (!mpy_half_isnan(a) && mpy_half_lt_nonan(b, a))

/**begin repeat
 *
 * #name = BOOL,
 *         BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = npy_bool,
 *         npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_datetime, npy_timedelta#
 * #isfloat = 0*11, 1*4, 0*2#
 * #isnan = nop*11, mpy_half_isnan, isnan*3, nop*2#
 * #lt = _LESS_THAN*11, _HALF_LESS_THAN, _LESS_THAN*5#
 * #gt = _GREATER_THAN*11, _HALF_GREATER_THAN, _GREATER_THAN*5#
 */
static void
@name@_fastclip(@type@ *in, npy_intp ni, @type@ *min, @type@ *max, @type@ *out, int device)
{
    npy_intp i;
    @type@ max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if @isfloat@
        /* NaNs result in no clipping, so optimize the case away */
        if (@isnan@(max_val)) {
            if (min == NULL) {
                #pragma omp target device(device) map(to: in, out, ni)
                memmove(out, in, ni * sizeof(@type@));
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if @isfloat@
        if (@isnan@(min_val)) {
            if (max == NULL) {
                #pragma omp target device(device) map(to: in, out, ni)
                memmove(out, in, ni * sizeof(@type@));
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        #pragma omp target device(device) map(to: in, out, ni, min_val)
        {
            for (i = 0; i < ni; i++) {
                if (@lt@(in[i], min_val)) {
                    out[i] = min_val;
                }
                else {
                    out[i] = in[i];
                }
            }
        }
    }
    else if (min == NULL) {
        #pragma omp target device(device) map(to: in, out, ni, max_val)
        {
            for (i = 0; i < ni; i++) {
                if (@gt@(in[i], max_val)) {
                    out[i] = max_val;
                }
                else {
                    out[i] = in[i];
                }
            }
        }
    }
    else {
        /*
         * Visual Studio 2015 loop vectorizer handles NaN in an unexpected
         * manner, see: https://github.com/numpy/numpy/issues/7601
         */
        #pragma omp target device(device) map(to: in, out, ni, min_val, max_val)
        {
            #if (_MSC_VER == 1900)
            #pragma loop( no_vector )
            #endif
            for (i = 0; i < ni; i++) {
                if (@lt@(in[i], min_val)) {
                    out[i]   = min_val;
                }
                else if (@gt@(in[i], max_val)) {
                    out[i]   = max_val;
                }
                else {
                    out[i] = in[i];
                }
            }
        }
    }
}
/**end repeat**/

#undef _LESS_THAN
#undef _GREATER_THAN
#undef _HALF_LESS_THAN
#undef _HALF_GREATER_THAN

/**begin repeat
 *
 * #name = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = npy_cfloat, npy_cdouble, npy_clongdouble#
 */
static void
@name@_fastclip(@type@ *in, npy_intp ni, @type@ *min, @type@ *max, @type@ *out, int device)
{
    npy_intp i;
    @type@ max_val, min_val;

    if (max != NULL) {
        max_val = *max;
    }
    if (min != NULL) {
        min_val = *min;
    }
    if (max == NULL) {
        #pragma omp target device(device) map(to: in, out, ni, min_val)
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i],min_val)) {
                out[i] = min_val;
            }
            else {
                out[i] = in[i];
            }
        }
    }
    else if (min == NULL) {
        #pragma omp target device(device) map(to: in, out, ni, max_val)
        for (i = 0; i < ni; i++) {
            if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
            else {
                out[i] = in[i];
            }
        }
    }
    else {
        #pragma omp target device(device) map(to: in, out, ni, min_val, max_val)
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i], min_val)) {
                out[i] = min_val;
            }
            else if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
            else {
                out[i] = in[i];
            }
        }
    }
}

/**end repeat**/

#define OBJECT_fastclip NULL


/*
 *****************************************************************************
 **                              FASTPUTMASK                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #name = BOOL,
 *         BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = npy_bool, npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_cfloat, npy_cdouble, npy_clongdouble,
 *         npy_datetime, npy_timedelta#
*/
static void
@name@_fastputmask(@type@ *in, npy_bool *mask, npy_intp ni, @type@ *vals,
        npy_intp nv, int device)
{
    npy_intp i, j;

    if (nv == 1) {
        @type@ s_val = *vals;

        #pragma omp target device(device) map(to: in, mask, ni, s_val)
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        #pragma omp target device(device) map(to: in, mask, ni, \
                                                  vals[0:nv], nv)
        for (i = 0, j = 0; i < ni; i++, j++) {
            if (j >= nv) {
                j = 0;
            }
            if (mask[i]) {
                in[i] = vals[j];
            }
        }
    }
    return;
}
/**end repeat**/

#define OBJECT_fastputmask NULL


/*
 *****************************************************************************
 **                                FASTTAKE                                 **
 *****************************************************************************
 */


#define OBJECT_fasttake NULL

/*
 *****************************************************************************
 **                       small correlate                                   **
 *****************************************************************************
 */


/*
 * Compute correlation of data with with small kernels
 * Calling a BLAS dot product for the inner loop of the correlation is overkill
 * for small kernels. It is faster to compute it directly.
 * Intended to be used by _pyarray_correlate so no input verifications is done
 * especially it does not handle the boundaries, they should be handled by the
 * caller.
 * Returns 0 if kernel is considered too large or types are not supported, then
 * the regular array dot should be used to process the data.
 *
 * d_, dstride, nd, dtype: data pointer, its stride in bytes, number of
 *                         elements and type of data
 * k_, kstride, nk, ktype: kernel pointer, its stride in bytes, number of
 *                         elements and type of data
 * out_, ostride: output data pointer and its stride in bytes
 */
NPY_NO_EXPORT int
small_correlate(const char * d_, npy_intp dstride,
                npy_intp nd, enum NPY_TYPES dtype,
                const char * k_, npy_intp kstride,
                npy_intp nk, enum NPY_TYPES ktype,
                char * out_, npy_intp ostride)
{
    /* only handle small kernels and uniform types */
    if (nk > 11 || dtype != ktype) {
        return 0;
    }

    switch (dtype) {
/**begin repeat
 * Float types
 *  #type = npy_float, npy_double#
 *  #TYPE = NPY_FLOAT, NPY_DOUBLE#
 */
        case @TYPE@:
            {
                npy_intp i;
                const @type@ * d = (@type@*)d_;
                const @type@ * k = (@type@*)k_;
                @type@ * out = (@type@*)out_;
                dstride /= sizeof(@type@);
                kstride /= sizeof(@type@);
                ostride /= sizeof(@type@);
                /* unroll inner loop to optimize register usage of the kernel*/
                switch (nk) {
/**begin repeat1
 *  #ksz_outer = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11# */
                    case @ksz_outer@:
                    {
/**begin repeat2
 *  #ksz = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11# */
#if @ksz@ <= @ksz_outer@
                        /* load kernel */
                        const @type@ k@ksz@ = k[(@ksz@ - 1) * kstride];
#endif
/**end repeat2**/
                        for (i = 0; i < nd; i++) {
                            @type@ s = 0;
/**begin repeat2
 *  #ksz = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11# */
#if @ksz@ <= @ksz_outer@
                            s += d[(i + @ksz@ - 1) * dstride] * k@ksz@;
#endif
/**end repeat2**/
                            out[i * ostride] = s;
                        }
                        return 1;
                    }
/**end repeat1**/
                    default:
                        return 0;
                }
            }
/**end repeat**/
        default:
            return 0;
    }
}

/*
 *****************************************************************************
 **                       SETUP FUNCTION POINTERS                           **
 *****************************************************************************
 */


/*
 *****************************************************************************
 **                             SETUP TYPE INFO                             **
 *****************************************************************************
 */


